摘自[https://yq.aliyun.com/articles/73518?spm=5176.100240.searchblog.24.PWxtEr]
一 编码习惯
	1 尽量避免分配内存
		a 避免创建一个短生命周期的临时对象（不是随便使用匿名对象）
			如果一个方法返回一个String，并且这个方法的返回值始终都是被用来appen到一个StringBuffer上
			就改为传入StringBuffer直接append上去
		b 如果使用的字符串是截取自某一个字符串，就直接从那个字符串上面substring，不要拷贝一份，
			因为通过substring虽然创建了新的String对象，但是共享了里面的char数组中的char对象，
			减少了这块对象的创建；
		c 尽量使用多个一维数组，其性能高于多维数组；int数组性能远大于Integer的性能
	
	2 尽可能使用static方法
		如果确定不需要访问类成员，让方法static，这样调用时可以提升15%~20%的速度，因为不需要切换对象的状态
	
	3 尽可能使用常量而非变量
		如果某个参数是常量，别忘了使用static final，这样可以让Class首次初始化时，
		不需要调用<clinit>来创建static方法，而是在编译时就直接将常量替换代码中使用的位置
	
	4 从性能层面出发，尽可能直接访问变量而非方法
		即时编译(Just-in-time Compilation，JIT)，又称动态转译(Dynamic Translation)，是一种通过在运行时将字节码翻译为机器码，从而改善字节码编译语言性能的技术。即时编译前期的两个运行时理论是字节码编译和动态编译。
		Android开发中，类内尽量避免通过get/set访问成员变量，虽然这在语言的开发中是一个好的习惯
		但是Android虚拟机中，对方法的调用开销远大于对变量的直接访问。在没有JIT的情况下，直接的
		变量访问比调用方法快3倍，在JIT下，直接的变量访问更是比调用方法快7倍
	
	5 对被内部类调用的方法/变量改为包可见
		当内部类需要访问外部类的私有方法/变量时，考虑将这些外部类的私有方法/变量改为包可见的方式。
		首先在编写代码的时候，通过内部类访问外部类的私有方法/变量时合法的，但是在编译的时候为了满足
		这个会将需要被被内部类访问的私有方法/变量封装一层包可见的方法，实现让内部类访问这些私有的方法/变量，
		根据前面我们又提到说方法的调用开销远大于变量的调用，因此这样使用性能变差。
	
	6 少用float
		
		a 尽量少用float，在很多现在设备中，double的性能与float的性能几乎没有差别，
			但是从大小上面double是float的俩倍的大小
		b 尽量考虑使用整形而非浮点型，在较好的Android设备中，浮点型比整形慢一倍
		
	7 使用乘法代替除法
		尽量不要使用除法操作，有很多处理器有乘法器，但是没有除法器，也就是说这些设备中需要将除法分解成其他的计算方式速度会比较慢
	
	8 使用内部实现，而非上层实现
		尽量使用系统Sdk提供的方法，而非自己去实现。如String.indexOf()相关的API，Dalvik将会替换为内部方法；
		System.arraycopy()方法在Nexus One手机上，会比我们上层写的类似方法的执行速度快9倍。
	
	9 权衡面向接口编程
		在没有JIT的设备中，面向接口编程的模式（如Map map），相比直接访问对象类（如HashMap map），会慢6%，
		但是存在JIT的设备中，二者的速度差不多，但是内存方面面向接口会变成消耗更多的内存，因此如果你的面向接口编程不是十分的必须可以考虑不用
		
	10 重复访问的变量，赋值为本地变量
		在没有JIT的设备中，访问本地化变量与成员比那两会快20%，但是存在JIT的设备中，二者速度差不多
	
	11 遍历优化
		尽量使用Iterable而不是通过长度判断来进行遍历
		list l = new ArrayList();
		Iterator iter = l.iterator();
		while(iter.hasNext()){
			String str = (String) iter.next();
			System.out.println(str);
	   }

二 数据库相关
	
	建多索引的原则：哪个字段可以最快的减少查询结果，就把该字段放在最前面
	
	1 无法使用索引的情况
		a 操作符BETWEEN、LIKE、OR
		b 表达式
		c CASE WHEN
	
	2 不推荐
		a 不要涉及索引是其他索引的前缀（没有意义）
		b 更新时拒绝直接全量更新，要更新哪列就put哪列的数据
		c 如果最频繁的是更新与插入，别建很多索引（原本表舅很小就饿没有必要建）
		d 拒绝用大字符串创建索引
		e 避免建太多索引，查询时可能就不会选择最好的来执行
		
	3 推荐
		a 多使用整形索引，效率远高于字符串索引
		b 搜索时使用SQL参数（?,parameter）代替字符串拼接（底层有特殊优化和缓存）
		c 查询需要多少就limit多少（如判断是否含有啥，就limit就行了）
		d 如果出现很宽的列（如blob类型），考虑在单独的表中（在查询或者更新其他列数据时防止不必要的大数据io应县性能）

三 网络调优

	策略层面的优化
	网络评估 心跳间隔 超时间隔，这些往往是基于特定环境下指定算法，然后结合自己的经验值给出的结论

	策略层面优化
	1 通过 If-Modified-Since 与 Last-Modified
		a 第一次请求时，服务端在头部通过 Last-Modified 带下来最后一次修改的时间
		b 之后的请求，在请求头中通过 If-Modified-Since 带上之前服务端返回的 Last-Modified 的值
		c 如果服务端判断最后一次修改的时间距离目前数据没有修改过，就直接返回 304 NOT MODIFIED 的状态吗，此时客户端直接
			呈现之前的数据，由于不需要带下来重复的数据，减少用户流量的同时也提高了响应的速度
	
	2 通过 Etag 与 If-None-Match
		a 第一次请求时，服务端在头部通过 Etag 带下来请求数据的 hash 值
		b 之后的请求，在请求头中通过 If-None-Match 带上之前服务端返回的 Etag 的值
		c 如果服务端判断文件没有修改过，就直接返回304 NOT MODIFIED，此时客户端直接呈现之前的数据，
			由于不需要带下来重复的数据，减少用户流量的同时也提高了响应速度。

	数据结构层面
	1 如果是需要全局数据的，考虑使用 Protobuffers（序列化反序列化高于json），并且考虑 nano protocol buffer。
	
	2 如果传输回来的数据不需要全量读取，考虑使用 Flatbuffers（序列化反序列化几乎不耗时，耗时是在读取对象时）

	其他层面优化
	1 通过自实现 DNS（如实现自己的HTTPDNS（用Okhttp3实现尤为简单，因为Okhttp3支持定制DNS）），来降低没必要的
		DNS更新（由于DNS常见策略是与文件大小以及TTL相关，如果我们份文件以及分域名协商TTl有效期，可能case by case 
		有效这块的刷新率），甚至防止DNS劫持
	
	2 图片 JS CSS等静态资源，采用CDN（当然如果是使用7牛之类的服务就已经给你搭建布置好了）
	
	3 全局图片处理采用漏斗模型全局管控，所请求的图片大小最好依照业务大小提供/最大不超过屏幕分辨率需要，
		如果请求原图，也不要超过 GL10.GL_MAX_TEXTRUE_SIZE 
	
	4 全局缩略图直接采用webp，在尽可能不损失图片质量的前提下，图片大小与png比缩小30%~70%
	
	5 如果列表里的缩略图服务器处理好的小图，考虑到减少下载时的RTT，可以考虑直接在列表数据请求中，直接以
		base64在列表数据直接带上图片（但是需要注意的是通常base64后的图片大小会大于原图片大小，适当权衡）
		
	6 轮询或者socket心跳采用系统 AlarmManager 提供闹钟服务来做，保证在系统休眠的时候cpu可以得到休眠，在需要唤醒时
		可以唤醒（持有cpu唤醒锁），考虑省电问题
		
	7 在一些异步的任务时，可以考虑合并请求

四 多进程抉择
	360 17个进程
	考虑到多进程的消耗，需要多个组件复用统一进程
	在没有做任何操作的空进程而言，其大约需要额外暂用1.4MB的内存
	
	1 充分独立，解耦部分
	
	2 大内存（如临时展示大量图片的Activity） 无法解决的crash、内存泄漏等问题，考虑通过独立进程解决
	
	3 独立于UI进程，需要在后台长期存活的服务
	
	4 非己方第三方库（无法保证稳定、性能等问题，并且独立组件），可考虑独立进程
	
	问题
		1 由于进程间通讯或者首次调起进程的消耗等，带来cpu、i/o等资源竞争
		2 可读性，多了层IPC
		
五 UI层面
	1 考虑使用ConstraintLayout，有效减少了布局的层级，提高了性能
	
	2 减少不必要的不透明背景相互覆盖，减少重绘，因为GPU不得不一遍又一遍的画这些图层
	
	3 保证UI线程一次完成绘制（measure、layout、draw）不超过16ms（60Hz），否则就会出现掉帧，卡顿的现象
	
	4 在UI线程中频繁的调度中，尽量少的对象创建，减少gc等
	
	5 分步加载(减少任务颗粒)、预加载、异步加载（区别出耗时任务，采用异步加载）
	
六 内存
	根据设备可用内存的不同，每个设备给应用设定的heap大小是有限的，当达到对应限定值还申请空间时，就会到OOM的异常
	
	1 内存管理
	
	在后台进程的LRU队列中，除了LRU为主要的规则以外，系统也会根据杀死一个后台进程所获得的的内存是否更多作为一定的参考依据
		因此后台进程为了保活，尽量少的内存，尽可能的释放内存也是十分必须的
		a 尽可能的缩短Service的存活周期（可以考虑直接使用执行完任务直接关闭自己的IntentService），也就是说在Service没有任何任务的
			时候，尽可能的将其关闭，以减少系统资源的浪费
		
		b 可以通过系统服务ActivityManager中getMemoryClas()获知当前设备允许每个应用大概可以有多少兆的内存使用
			如果在AndroidManifest设置了largeHeap=true，使用getLargeMemoryClas()获知，并且让应用中的内存始终低于这个值，表面OOM
		
		c 相对于静态常量而言，通常Enum枚举需要大于俩倍的内存空间来存储相同的数据
		
		d Java中每个Class或者匿名类大约占用500字节
		
		e 每个对象实例大约开销12~16字节的内存
		
	onTrimMemory()回调处理
		监听onTrimMemory()的回调，根据不同的内存等级，做出相应的释放以此让系统资源更好的利用，以及自己的进程可以更好的保活
	
	当应用还在前台
		TRIM_MEMORY_RUNNING_MODERATE: 当前应用还在运行不会被杀，但是设备可运行的内存较低，系统正在从后台进程的LRU列表中杀死进程其他进程。
		TRIM_MEMORY_RUNNING_LOW: 当前应用还在运行不会被杀，但是设备可运行内存很低了，会直接影响当前应用的性能，当前应用也需要考虑释放一些无用资源。
		TRIM_MEMORY_RUNNING_CRITICAL: 当前应用还在运行中，但是系统已经杀死了后台进程LRU队列中绝大多数的进程了，当前应用需要考虑释放所有不重要的资源，否则很可能系统就会开始清理服务进程，可见进程等。也就说，如果内存依然不足以支撑，当前应用的服务也很有可能会被清理掉。
		TRIM_MEMORY_UI_HIDDEN：当回调回来的时候，说明应用的UI对用户不可见的，此时释放UI使用的一些资源。这个不同于onStop()，onStop()的回调，有可能仅仅是当前应用中进入了另外一个Activity。
	
	当应用处于后台
		TRIM_MEMORY_BACKGROUND: 系统已经处于低可用内存的情况，并且当前进程处于后台进程LRU队列队头附近，因此还是比较安全的，但是系统可能已经开始从LRU队列中清理进程了，此时当前应用需要释放部分资源，以保证尽量的保活。
		TRIM_MEMORY_MODERATE: 系统处于低可用内存的情况，并且当前进程处于后台进程LRU队列中间的位置，如果内存进一步紧缺，当前进程就有可能被清理掉，需要进一步释放资源。
		TRIM_MEMORY_COMPLETE: 系统处于低可用内存的情况，并且当前进程处于后天进程LRU队列队首的位置，如果内存进一步紧缺，下一个清理的就是当前进程，需要释放尽可能的资源来保活当前进程。在API14之前，onLowMemory()就相当于这个级别的回调。
		
	2 避免内存泄漏相关
		1 无法解决的泄漏（如系统层引起的）移至独立进程（如2.x机器存在webview的内存泄漏）
		2 大图片资源/全屏图片资源，要不放在assets下，要不放在nodpi下，要不都带，否则缩放会带来额外耗时与内存问题
		3 4.x在AndroidManifest中配置largeHeap=true，一般dvm heep最大值可增大50%以上。但是没有特殊明确的需要，尽可能的避免这样设置，
			因为这样一来很可能隐藏了消耗了完全没有必要的内存的问题
		4 在Activity#onDestory以后，遍历所有View，干掉所有View可能的引用(通常泄漏一个Activity，连带泄漏其上的View，然后就泄漏了大于全屏图片的内存)。
		5 万金油: 静态化内部类，使用WeakReference引用外部类，防止内部类长期存在，泄漏了外部类的问题
	
	3 图片
		Android 2.3.x或更低版本的设备，是将所有的Bitmap对象存储在native heap，因此我们很难通过工具去检测其内存大小，在Android 3.0或更高版本的设备，已经调整为存储到了每个应用自身的Dalvik heap中了。
		
		1 全局统一BitmapFactory#decode出口，捕获此处decode oom，控制长宽（小于屏幕分辨率大小 ）
		2 如果采用RGB_8888 oom了，尝试RGB_565(相比内存小一半以上(w*h*2(bytes)))
		3 如果还考虑2.x机器的话，设置BitmapFactory#options的InNativeAlloc参数为true，此时decode的内存不会上报到dvm中，便不会oom。
		4 建议采用lingochamp/QiniuImageLoader的方式，所有图片的操作都放到云端处理，本地默认使用Webp，并且获取的每个位置的图片，尽量通过精确的大小按需获取，避免内存没必要的消耗。
		
七 线程
	1 采用全局线程池管理体系，有效避免野线程
	2 结合全局线程池管理体系，使用 ThreadDebugger监控线程，避免线程泄漏的存在